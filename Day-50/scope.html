<h1>Scope in js</h1>

<h3>block scope</h3>

<script>
    {
        var y = 3
        let x = 3;
        document.write("X = ", x, " is accessible inside block <br>")
        document.write("y = ", y, " is accessible inside block <br>")
    }
    // document.write("X = ", x, "is not accessible outside block")
    document.write("y = ", y, " is accessible outside block(function scope) <br>")
</script>

<br>


<h1>Hoisting in js</h1>

<h3>
    <pre>
        What is Hoisting?
        
        Hoisting is a JavaScript behavior where variable and function declarations are moved to the top of their scope during
        the execution phase, before the code runs.
    </pre>
</h3>
<p>When you use var, JavaScript hoists the declaration to the top, but not the value. So if you try to use the variable
    before assigning a value, you'll get undefined.</p>
<script>
    console.log(a)    // undefined
    var a = 2;
</script>

<br>

<h3>
    <pre>
        Hoisting with let and const
        
        When you use let or const, the declaration is hoisted, but JavaScript doesn't allow you to access the variable before
        its actual declaration line. Trying to do so will cause a ReferenceError.
    </pre>
</h3>
<p>Why?: JavaScript hoists the declaration, but you can't use it until the line let a = 5; is reached. This creates a "dead
zone" where the variable exists but isn't accessible yet.</p>
<script>
    console.log(b)    // ref error
    let b;
    // a = 5;
</script>



<br>

<h3>
    <pre>
        3. Hoisting with Functions
        
        Function declarations are fully hoisted, which means you can call the function before you write it in the code.
        Example with Function Declaration:
        
        myFunction(); // Works fine
        function myFunction() {
        console.log("Hello!");
        }
        
        Why?: The entire function myFunction is hoisted, including its body, so you can call it even before you see it in the
        code.
        
        Example with Function Expression (using var):
        
        myFunction(); // TypeError: myFunction is not a function
        var myFunction = function() {
        console.log("Hello!");
        };
        
        Why?: With a function expression (like var myFunction = function() {...}), only the declaration var myFunction; is
        hoisted. The assignment myFunction = function() {...} happens later in the code, so calling it before that line gives a
        TypeError.
    </pre>
</h3>

<script>
    myFunction(); // Works fine
        function myFunction() {
            console.log("Hello!");
        }
    
</script>