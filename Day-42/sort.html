If you want to sort an array in JavaScript without using the built-in sort() method, you can implement a sorting
algorithm manually. Here are a few common sorting algorithms you can use:
1. Bubble Sort

Bubble Sort is a simple comparison-based algorithm. It repeatedly steps through the list, compares adjacent elements,
and swaps them if they are in the wrong order. The pass through the list is repeated until the list is sorted.

javascript

function bubbleSort(arr) {
let n = arr.length;
let swapped;
do {
swapped = false;
for (let i = 0; i < n - 1; i++) { if (arr[i]> arr[i + 1]) {
    [arr[i], arr[i + 1]] = [arr[i + 1], arr[i]]; // Swap
    swapped = true;
    }
    }
    n--; // Each pass ensures the largest element is at the end
    } while (swapped);
    return arr;
    }

    let numbers = [64, 34, 25, 12, 22, 11, 90];
    console.log(bubbleSort(numbers)); // [11, 12, 22, 25, 34, 64, 90]

    2. Selection Sort

    Selection Sort repeatedly selects the smallest element from the unsorted portion of the array and moves it to the
    beginning.

    javascript

    function selectionSort(arr) {
    let n = arr.length;
    for (let i = 0; i < n - 1; i++) { let minIndex=i; for (let j=i + 1; j < n; j++) { if (arr[j] < arr[minIndex]) {
        minIndex=j; } } if (minIndex !==i) { [arr[i], arr[minIndex]]=[arr[minIndex], arr[i]]; // Swap } } return arr; }
        let numbers=[64, 34, 25, 12, 22, 11, 90]; console.log(selectionSort(numbers)); // [11, 12, 22, 25, 34, 64, 90]
        3. Insertion Sort Insertion Sort builds the final sorted array one item at a time. It picks the next item and
        inserts it into its correct position. javascript function insertionSort(arr) { let n=arr.length; for (let i=1; i
        < n; i++) { let key=arr[i]; let j=i - 1; while (j>= 0 && arr[j] > key) {
        arr[j + 1] = arr[j];
        j--;
        }
        arr[j + 1] = key;
        }
        return arr;
        }

        let numbers = [64, 34, 25, 12, 22, 11, 90];
        console.log(insertionSort(numbers)); // [11, 12, 22, 25, 34, 64, 90]

        4. Merge Sort

        Merge Sort is a divide-and-conquer algorithm that splits the array into halves, recursively sorts each half, and
        then merges the sorted halves.

        javascript

        function mergeSort(arr) {
        if (arr.length <= 1) return arr; const mid=Math.floor(arr.length / 2); const left=arr.slice(0, mid); const
            right=arr.slice(mid); return merge(mergeSort(left), mergeSort(right)); } function merge(left, right) { let
            result=[]; let leftIndex=0; let rightIndex=0; while (leftIndex < left.length && rightIndex < right.length) {
            if (left[leftIndex] < right[rightIndex]) { result.push(left[leftIndex]); leftIndex++; } else {
            result.push(right[rightIndex]); rightIndex++; } } return
            result.concat(left.slice(leftIndex)).concat(right.slice(rightIndex)); } let numbers=[64, 34, 25, 12, 22, 11,
            90]; console.log(mergeSort(numbers)); // [11, 12, 22, 25, 34, 64, 90] 5. Quick Sort Quick Sort is another
            divide-and-conquer algorithm that selects a 'pivot' element, partitions the array into elements less than
            and greater than the pivot, and recursively sorts the partitions. javascript function quickSort(arr) { if
            (arr.length <=1) return arr; let pivot=arr[Math.floor(arr.length / 2)]; let left=arr.filter(x=> x < pivot);
                let middle=arr.filter(x=> x === pivot);
                let right = arr.filter(x => x > pivot);

                return [...quickSort(left), ...middle, ...quickSort(right)];
                }

                let numbers = [64, 34, 25, 12, 22, 11, 90];
                console.log(quickSort(numbers)); // [11, 12, 22, 25, 34, 64, 90]

                Each sorting algorithm has its own characteristics and performance considerations, so you might choose
                one based on your specific needs and the size of the data you're working with.